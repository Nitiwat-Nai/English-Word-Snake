<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>English Word Snake Game üêç (Premium Jungle)</title>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* --- THEME & GLOBAL STYLES (Premium Jungle Theme) --- */
        :root {
            /* Jungle Theme Colors */
            --color-primary: #2E7D32;
            --color-primary-dark: #1B5E20;
            --color-accent: #FFD700;
            --color-bg: #E8F5E9;
            --color-card-bg: #FFFFFF;
            --color-text-dark: #1A3C34;
            --color-text-light: #FFFFFF;

            /* Snake Colors */
            --color-snake-head: #00695C;
            --color-snake-body: #4DB6AC;
            --color-board-bg: #F1F8E9;
            --color-board-border: #33691E;

            /* Letter Colors */
            --color-letter-target: #D32F2F;
            --color-letter-non-target: #FFECB3;
            --color-letter-text: #3E2723;
            --color-golden-fruit: #FFD700;

            /* Difficulty Colors */
            --color-easy: #FFCA28;
            --color-medium: #66BB6A;
            --color-hard: #42A5F5;

            /* Config */
            --grid-size: 15;
            /* Control Size - ‡πÉ‡∏´‡∏ç‡πà‡∏Ç‡∏∂‡πâ‡∏ô */
            --control-size: 75px; 
        }

        @media (max-width: 450px) {
            :root {
                --control-size: 65px;
            }
        }

        body {
            font-family: 'Sarabun', sans-serif;
            background: linear-gradient(135deg, #f0e68c 0%, #e0c598 100%);
            color: var(--color-text-dark);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            overflow-x: hidden;
            overscroll-behavior: none;
        }

        .container {
            width: 100%;
            max-width: 500px;
            background-color: rgba(255, 255, 255, 0.95);
            box-shadow: 0 20px 50px rgba(0, 50, 0, 0.3);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            backdrop-filter: blur(10px);
        }

        header {
            background: linear-gradient(to right, var(--color-primary-dark), var(--color-primary));
            color: var(--color-text-light);
            padding: 1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border-bottom-left-radius: 20px;
            border-bottom-right-radius: 20px;
            margin-bottom: 1rem;
            position: relative;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header h1 {
            font-size: 1.5rem;
            margin: 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            letter-spacing: 1px;
            transition: transform 0.3s;
        }

        /* --- Animation for Bot Mode (Heartbeat) --- */
        @keyframes heartbeat {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .bot-active header h1 {
            animation: heartbeat 1.5s infinite ease-in-out;
            /* No color change, just animation */
        }

        /* Pause Button */
        #btn-pause {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: white;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .screen {
            padding: 1rem;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            box-sizing: border-box;
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Buttons --- */
        .btn-3d {
            border: none;
            cursor: pointer;
            font-family: 'Sarabun', sans-serif;
            font-weight: 900;
            font-size: 1.1rem;
            padding: 1rem 2rem;
            border-radius: 50px;
            color: white;
            transition: transform 0.1s, box-shadow 0.1s;
            width: 100%;
            margin-bottom: 10px;
            position: relative;
            overflow: hidden;
            user-select: none; 
            -webkit-user-select: none;
        }

        .btn-3d:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 transparent !important;
        }

        .btn-easy { background: var(--color-easy); box-shadow: 0 5px 0 #FFB300; color: #3E2723; }
        .btn-medium { background: var(--color-medium); box-shadow: 0 5px 0 #388E3C; }
        .btn-hard { background: var(--color-hard); box-shadow: 0 5px 0 #1565C0; }
        .btn-primary { background: var(--color-primary); box-shadow: 0 5px 0 var(--color-primary-dark); }
        .btn-danger { background: #E53935; box-shadow: 0 5px 0 #C62828; }

        /* --- Game Board (UPDATED SIZE) --- */
        .game-container {
            /* ‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô ‡πÉ‡∏ä‡πâ % ‡πÅ‡∏•‡∏∞ aspect-ratio ‡πÅ‡∏ó‡∏ô pixel fix */
            width: 96%;
            max-width: 480px; 
            aspect-ratio: 1 / 1;
            
            display: grid;
            grid-template-columns: repeat(var(--grid-size), 1fr);
            grid-template-rows: repeat(var(--grid-size), 1fr);
            
            border: 6px solid var(--color-board-border);
            border-radius: 10px;
            background-color: var(--color-board-bg);
            /* Updated grid pattern to match fluid width */
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
            background-size: calc(100% / var(--grid-size)) calc(100% / var(--grid-size));
            
            margin: 10px auto;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.1);
            position: relative;
            touch-action: none;
        }

        .cell {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 4px;
            /* Make font size responsive to cell */
            font-size: clamp(10px, 3.5vw, 16px);
        }

        /* Snake Styles */
        .snake-head {
            background: var(--color-snake-head);
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 2;
            position: relative;
            transform-origin: center center;
            transition: transform 0.1s;
        }

        .snake-head[data-dir="UP"] { transform: rotate(-90deg); }
        .snake-head[data-dir="DOWN"] { transform: rotate(90deg); }
        .snake-head[data-dir="LEFT"] { transform: rotate(180deg); }
        .snake-head[data-dir="RIGHT"] { transform: rotate(0deg); }

        .snake-head.eaten[data-dir="UP"] { transform: rotate(-90deg) scale(1.3); }
        .snake-head.eaten[data-dir="DOWN"] { transform: rotate(90deg) scale(1.3); }
        .snake-head.eaten[data-dir="LEFT"] { transform: rotate(180deg) scale(1.3); }
        .snake-head.eaten[data-dir="RIGHT"] { transform: rotate(0deg) scale(1.3); }

        .snake-head::before, .snake-head::after {
            content: ''; position: absolute; width: 4px; height: 4px;
            background: white; border-radius: 50%; border: 1px solid black; right: 20%;
        }
        .snake-head::before { top: 25%; }
        .snake-head::after { bottom: 25%; }

        .snake-body {
            background: var(--color-snake-body);
            border-radius: 30%;
            transform: scale(0.9);
        }
        .snake-tail {
            background: var(--color-snake-body);
            border-radius: 50%;
            transform: scale(0.7);
        }

        .snake-body.flash-active, .snake-tail.flash-active {
            transform: scale(1.15);
            box-shadow: 0 0 15px white, 0 0 10px var(--color-accent);
            transition: transform 0.1s;
        }

        /* Letters */
        .letter-piece {
            font-weight: 900;
            border-radius: 50%;
            color: var(--color-letter-text);
            background: var(--color-letter-non-target);
            box-shadow: 0 3px 0 rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }
        .letter-piece.target {
            background: var(--color-letter-target);
            color: white;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }

        .golden-fruit {
            background: var(--color-golden-fruit);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--color-golden-fruit);
            animation: spin 2s linear infinite;
        }
        .golden-fruit::after { content: '‚≠ê'; font-size: 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- HUD --- */
        .hud-panel {
            background: rgba(255, 255, 255, 0.8);
            padding: 8px 15px;
            border-radius: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            width: 95%;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .score-display { font-weight: 900; color: var(--color-primary-dark); font-size: 1.2rem; }
        .word-display { font-size: 1.3rem; font-weight: 900; color: var(--color-primary); letter-spacing: 2px; }
        .word-display .collected-char { color: var(--color-snake-head); }
        .word-display .target-char { color: var(--color-letter-target); }

        /* --- Controls (LARGER) --- */
        .controls-area {
            display: grid;
            grid-template-areas: ". up ." "left down right";
            gap: 10px;
            margin-top: 15px;
        }

        .ctrl-btn {
            width: var(--control-size);
            height: var(--control-size);
            border-radius: 50%;
            border: none;
            background: var(--color-primary);
            color: white;
            font-size: 2rem; /* Icon larger */
            box-shadow: 0 6px 0 var(--color-primary-dark), 0 10px 10px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: transform 0.1s;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .ctrl-btn:active { transform: translateY(6px); box-shadow: 0 0 0 var(--color-primary-dark); }
        #ctrl-up { grid-area: up; }
        #ctrl-left { grid-area: left; }
        #ctrl-down { grid-area: down; }
        #ctrl-right { grid-area: right; }
        
        .ctrl-btn.pressed-sim { transform: translateY(6px); box-shadow: 0 0 0 var(--color-primary-dark); filter: brightness(0.8); }

        /* --- Overlay --- */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            display: flex; justify-content: center; align-items: center; z-index: 100;
        }

        .modal {
            background: white; padding: 2rem; border-radius: 20px;
            width: 80%; max-width: 350px; text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .hidden { display: none !important; }
        
        .sub-level-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; }
        
        #pause-indicator {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 4px 10px rgba(0,0,0,0.5);
            pointer-events: none;
            display: none;
            z-index: 50;
        }
    </style>
</head>

<body id="game-body">

    <div class="container">
        <header>
            <h1 id="game-title">Word Snake üêç</h1>
            <button id="btn-pause" onclick="togglePause()" class="hidden">‚ùö‚ùö</button>
        </header>

        <div id="start-screen" class="screen" style="display: flex;">
            <h2 style="color: var(--color-primary-dark);">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏Å</h2>
            <div style="width: 100%; max-width: 300px;">
                <button class="btn-3d btn-easy" onclick="unlockAudio(); showSubLevels('easy')">‡∏£‡∏∞‡∏î‡∏±‡∏ö ‡∏á‡πà‡∏≤‡∏¢ (‡∏ä‡πâ‡∏≤)</button>
                <button class="btn-3d btn-medium" onclick="unlockAudio(); showSubLevels('medium')">‡∏£‡∏∞‡∏î‡∏±‡∏ö ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á (‡∏õ‡∏Å‡∏ï‡∏¥)</button>
                <button class="btn-3d btn-hard" onclick="unlockAudio(); showSubLevels('hard')">‡∏£‡∏∞‡∏î‡∏±‡∏ö ‡∏¢‡∏≤‡∏Å (‡πÄ‡∏£‡πá‡∏ß)</button>
            </div>

            <div id="sub-level-area" class="hidden" style="width: 100%; margin-top: 20px;">
                <h3 id="sub-level-title" style="margin: 0 0 10px 0;">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏î‡πà‡∏≤‡∏ô</h3>
                <div id="sub-level-buttons" class="sub-level-grid"></div>
                <button class="btn-3d btn-danger" style="margin-top: 15px;" onclick="backToMain()">‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö</button>
            </div>
            
            <p style="margin-top:20px; font-size:0.8rem; color:#666;">
                *‡∏õ‡∏±‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠ ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á
            </p>
        </div>

        <div id="game-screen" class="screen">
            <div class="hud-panel">
                <div>
                    <div style="font-size: 0.8rem; color: #666;">SCORE</div>
                    <div id="score-val" class="score-display">0</div>
                </div>
                <div style="text-align: right;">
                    <div style="font-size: 0.8rem; color: #666;">TARGET</div>
                    <div id="target-letter" class="score-display"
                        style="color: var(--color-letter-target); font-size: 1.5rem;">A</div>
                </div>
            </div>

            <div id="word-progress" class="word-display">_ _ _</div>
            <div style="font-size: 0.9rem; color: #555; margin-bottom: 5px;">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡∏ó‡∏µ‡πà‡∏™‡∏∞‡∏™‡∏°</div>

            <div id="game-board" class="game-container">
                <div id="pause-indicator">PAUSED</div>
            </div>

            <div class="controls-area">
                <button id="ctrl-up" class="ctrl-btn">‚¨ÜÔ∏è</button>
                <button id="ctrl-left" class="ctrl-btn">‚¨ÖÔ∏è</button>
                <button id="ctrl-down" class="ctrl-btn">‚¨áÔ∏è</button>
                <button id="ctrl-right" class="ctrl-btn">‚û°Ô∏è</button>
            </div>
        </div>

        <div id="summary-screen" class="screen">
            <h2 style="color: var(--color-primary);">üéâ ‡∏à‡∏ö‡πÄ‡∏•‡πÄ‡∏ß‡∏•!</h2>
            <div style="background: white; padding: 15px; border-radius: 10px; width: 100%; margin-bottom: 20px; box-shadow: inset 0 0 10px rgba(0,0,0,0.05); max-height: 250px; overflow-y: auto;">
                <ul id="summary-list" style="list-style: none; padding: 0; text-align: left;"></ul>
            </div>
            <button class="btn-3d btn-primary" id="btn-next-level">‡∏î‡πà‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏õ</button>
            <button class="btn-3d btn-danger" onclick="backToMain()">‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å</button>
        </div>

        <div id="overlay" class="hidden">
            <div class="modal">
                <h2 id="modal-title">‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÑ‡∏´‡∏°?</h2>
                <p id="modal-msg">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå: CAT</p>
                <button id="modal-btn" class="btn-3d btn-primary">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°</button>
                <button id="modal-back-btn" class="btn-3d btn-danger hidden" onclick="backToMain()">‡∏≠‡∏≠‡∏Å</button>
                <button id="modal-resume-btn" class="btn-3d btn-medium hidden" onclick="togglePause()">‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠</button>
            </div>
        </div>
    </div>

    <script>
        // --- AUDIO SYSTEM ---
        class SoundManager {
            constructor() { this.ctx = null; this.enabled = true; }
            init() {
                if (!this.ctx) { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
                if (this.ctx.state === 'suspended') { this.ctx.resume(); }
            }
            playTone(freq, type, duration, vol = 0.1) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }
            playEat() { this.playTone(600, 'sine', 0.1, 0.2); setTimeout(() => this.playTone(800, 'sine', 0.1, 0.2), 50); }
            playWrong() { this.playTone(150, 'sawtooth', 0.3, 0.3); }
            playBonus() { this.playTone(1000, 'triangle', 0.1, 0.2); setTimeout(() => this.playTone(1500, 'triangle', 0.2, 0.2), 100); }
            playWin() { [523, 659, 784, 1046].forEach((f, i) => setTimeout(() => this.playTone(f, 'square', 0.2, 0.1), i * 100)); }
            playGameOver() { [400, 300, 200, 100].forEach((f, i) => setTimeout(() => this.playTone(f, 'sawtooth', 0.3, 0.2), i * 150)); }
        }
        const audio = new SoundManager();
        const synth = window.speechSynthesis;

        function unlockAudio() {
            audio.init();
            if (synth && !synth.speaking) { const u = new SpeechSynthesisUtterance(''); synth.speak(u); }
        }

        function speak(text, onEndCallback = () => {}) {
            if (synth.speaking) synth.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'en-US';
            u.rate = 0.8;
            let finished = false;
            const finishOnce = () => { if(!finished) { finished = true; onEndCallback(); } };
            u.onend = finishOnce;
            u.onerror = finishOnce;
            setTimeout(finishOnce, 2000);
            synth.speak(u);
        }

        // --- DATA ---
        const WORDS = {
            'easy': [
                [{ w: 'CAT', t: '‡πÅ‡∏°‡∏ß' }, { w: 'DOG', t: '‡∏™‡∏∏‡∏ô‡∏±‡∏Ç' }, { w: 'SUN', t: '‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå' }],
                [{ w: 'FISH', t: '‡∏õ‡∏•‡∏≤' }, { w: 'BIRD', t: '‡∏ô‡∏Å' }, { w: 'RAIN', t: '‡∏ù‡∏ô' }],
                [{ w: 'BALL', t: '‡∏•‡∏π‡∏Å‡∏ö‡∏≠‡∏•' }, { w: 'BOOK', t: '‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠' }, { w: 'GAME', t: '‡πÄ‡∏Å‡∏°' }],
                [{ w: 'FOUR', t: '‡∏™‡∏µ‡πà' }, { w: 'FIVE', t: '‡∏´‡πâ‡∏≤' }, { w: 'ZERO', t: '‡∏®‡∏π‡∏ô‡∏¢‡πå' }],
                [{ w: 'GIRL', t: '‡πÄ‡∏î‡πá‡∏Å‡∏´‡∏ç‡∏¥‡∏á' }, { w: 'BOY', t: '‡πÄ‡∏î‡πá‡∏Å‡∏ä‡∏≤‡∏¢' }, { w: 'KING', t: '‡∏û‡∏£‡∏∞‡∏£‡∏≤‡∏ä‡∏≤' }],
                [{ w: 'RICE', t: '‡∏Ç‡πâ‡∏≤‡∏ß' }, { w: 'MEAT', t: '‡πÄ‡∏ô‡∏∑‡πâ‡∏≠' }, { w: 'SOUP', t: '‡∏ã‡∏∏‡∏õ' }],
                [{ w: 'HAND', t: '‡∏°‡∏∑‡∏≠' }, { w: 'FOOT', t: '‡πÄ‡∏ó‡πâ‡∏≤' }, { w: 'EYE', t: '‡∏ï‡∏≤' }],
                [{ w: 'COLD', t: '‡∏´‡∏ô‡∏≤‡∏ß' }, { w: 'HOT', t: '‡∏£‡πâ‡∏≠‡∏ô' }, { w: 'WET', t: '‡πÄ‡∏õ‡∏µ‡∏¢‡∏Å' }],
                [{ w: 'FROG', t: '‡∏Å‡∏ö' }, { w: 'SHIP', t: '‡πÄ‡∏£‡∏∑‡∏≠' }, { w: 'BLUE', t: '‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô' }],
                [{ w: 'SMILE', t: '‡∏¢‡∏¥‡πâ‡∏°' }, { w: 'LAUGH', t: '‡∏´‡∏±‡∏ß‡πÄ‡∏£‡∏≤‡∏∞' }, { w: 'SLEEP', t: '‡∏ô‡∏≠‡∏ô' }]
            ],
            'medium': [
                [{ w: 'ORANGE', t: '‡∏™‡πâ‡∏°' }, { w: 'TICKET', t: '‡∏ï‡∏±‡πã‡∏ß' }, { w: 'PURPLE', t: '‡∏™‡∏µ‡∏°‡πà‡∏ß‡∏á' }],
                [{ w: 'SCHOOL', t: '‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô' }, { w: 'TRAVEL', t: '‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á' }, { w: 'FRIEND', t: '‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô' }],
                [{ w: 'MORNING', t: '‡πÄ‡∏ä‡πâ‡∏≤' }, { w: 'EVENING', t: '‡πÄ‡∏¢‡πá‡∏ô' }, { w: 'WEEKEND', t: '‡∏ß‡∏±‡∏ô‡∏´‡∏¢‡∏∏‡∏î' }],
                [{ w: 'GARDEN', t: '‡∏™‡∏ß‡∏ô' }, { w: 'KITCHEN', t: '‡∏´‡πâ‡∏≠‡∏á‡∏Ñ‡∏£‡∏±‡∏ß' }, { w: 'WINDOW', t: '‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á' }],
                [{ w: 'PICTURE', t: '‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û' }, { w: 'CAMERA', t: '‡∏Å‡∏•‡πâ‡∏≠‡∏á' }, { w: 'JOURNAL', t: '‡∏ß‡∏≤‡∏£‡∏™‡∏≤‡∏£' }],
                [{ w: 'HAPPEN', t: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô' }, { w: 'FINISH', t: '‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô' }, { w: 'ACCEPT', t: '‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö' }],
                [{ w: 'WEATHER', t: '‡∏≠‡∏≤‡∏Å‡∏≤‡∏®' }, { w: 'CLOUDY', t: '‡∏°‡∏µ‡πÄ‡∏°‡∏Ü‡∏°‡∏≤‡∏Å' }, { w: 'SUNNY', t: '‡∏°‡∏µ‡πÅ‡∏î‡∏î' }],
                [{ w: 'MONSTER', t: '‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏õ‡∏£‡∏∞‡∏´‡∏•‡∏≤‡∏î' }, { w: 'SECRET', t: '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏±‡∏ö' }, { w: 'PUZZLE', t: '‡∏õ‡∏£‡∏¥‡∏®‡∏ô‡∏≤' }],
                [{ w: 'BROTHER', t: '‡∏û‡∏µ‡πà/‡∏ô‡πâ‡∏≠‡∏á‡∏ä‡∏≤‡∏¢' }, { w: 'SISTER', t: '‡∏û‡∏µ‡πà/‡∏ô‡πâ‡∏≠‡∏á‡∏™‡∏≤‡∏ß' }, { w: 'UNCLE', t: '‡∏•‡∏∏‡∏á/‡∏ô‡πâ‡∏≤/‡∏≠‡∏≤' }],
                [{ w: 'MOUNTAIN', t: '‡∏†‡∏π‡πÄ‡∏Ç‡∏≤' }, { w: 'FOREST', t: '‡∏õ‡πà‡∏≤' }, { w: 'PLANET', t: '‡∏î‡∏≤‡∏ß‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå' }]
            ],
            'hard': [
                [{ w: 'DICTATION', t: '‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ï‡∏≤‡∏°‡∏Ñ‡∏≥‡∏ö‡∏≠‡∏Å' }, { w: 'AMAZEMENT', t: '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡∏´‡∏•‡∏≤‡∏î‡πÉ‡∏à' }, { w: 'ADVENTURE', t: '‡∏Å‡∏≤‡∏£‡∏ú‡∏à‡∏ç‡∏†‡∏±‡∏¢' }],
                [{ w: 'COMPUTER', t: '‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå' }, { w: 'TELEVISION', t: '‡πÇ‡∏ó‡∏£‡∏ó‡∏±‡∏®‡∏ô‡πå' }, { w: 'KNOWLEDGE', t: '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ' }],
                [{ w: 'COMMUNITY', t: '‡∏ä‡∏∏‡∏°‡∏ä‡∏ô' }, { w: 'ECOLOGY', t: '‡∏ô‡∏¥‡πÄ‡∏ß‡∏®‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤' }, { w: 'EDUCATION', t: '‡∏Å‡∏≤‡∏£‡∏®‡∏∂‡∏Å‡∏©‡∏≤' }],
                [{ w: 'IMPORTANT', t: '‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç' }, { w: 'DIFFERENT', t: '‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á' }, { w: 'INTEREST', t: '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ô‡πÉ‡∏à' }],
                [{ w: 'CHOCOLATE', t: '‡∏ä‡πá‡∏≠‡∏Å‡πÇ‡∏Å‡πÅ‡∏•‡∏ï' }, { w: 'CALCULATE', t: '‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì' }, { w: 'DISCOVER', t: '‡∏Ñ‡πâ‡∏ô‡∏û‡∏ö' }],
                [{ w: 'ATTENTION', t: '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ô‡πÉ‡∏à' }, { w: 'CAPABILITY', t: '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ' }, { w: 'DEFINITION', t: '‡∏Ñ‡∏≥‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°' }],
                [{ w: 'PROFESSION', t: '‡∏≠‡∏≤‡∏ä‡∏µ‡∏û' }, { w: 'VOLUNTEER', t: '‡∏≠‡∏≤‡∏™‡∏≤‡∏™‡∏°‡∏±‡∏Ñ‡∏£' }, { w: 'UNIVERSITY', t: '‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏•‡∏±‡∏¢' }],
                [{ w: 'CHAMPION', t: '‡πÅ‡∏ä‡∏°‡∏õ‡πå‡πÄ‡∏õ‡∏µ‡πâ‡∏¢‡∏ô' }, { w: 'DYNAMITE', t: '‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î' }, { w: 'FANTASTIC', t: '‡∏°‡∏´‡∏±‡∏®‡∏à‡∏£‡∏£‡∏¢‡πå' }],
                [{ w: 'TRANSPORT', t: '‡∏Ç‡∏ô‡∏™‡πà‡∏á' }, { w: 'COMPLEXITY', t: '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô' }, { w: 'CHALLENGES', t: '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡πâ‡∏≤‡∏ó‡∏≤‡∏¢' }],
                [{ w: 'UNBELIEVABLE', t: '‡πÑ‡∏°‡πà‡∏ô‡πà‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠' }, { w: 'INFORMATION', t: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•' }, { w: 'CONGRATULATIONS', t: '‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏î‡πâ‡∏ß‡∏¢' }]
            ]
        };

        // --- STATE & VARIABLES ---
        const GRID = 15;
        let snake = [], dir = { x: 1, y: 0 };
        let inputQueue = []; 
        let currentWord = '', currentWordObj = null, letterIdx = 0;
        let levelData = [], levelIdx = 0, wordIdx = 0;
        let letters = [], goldenFruit = null;
        let score = 0, gameInterval = null, isPlaying = false, isPaused = false;
        let difficulty = 'easy';
        let isHeadEaten = false, isBotActive = false; 
        let goldenFruitDespawnTimer = null, goldenFruitSpawnScheduler = null, lastPressedCtrl = null; 
        const SPEEDS = { 'easy': 280, 'medium': 220, 'hard': 160 };

        // --- DOM ELEMENTS ---
        const els = {
            screens: document.querySelectorAll('.screen'),
            board: document.getElementById('game-board'),
            subLevelArea: document.getElementById('sub-level-area'),
            subLevelBtns: document.getElementById('sub-level-buttons'),
            score: document.getElementById('score-val'),
            target: document.getElementById('target-letter'),
            wordProgress: document.getElementById('word-progress'),
            overlay: document.getElementById('overlay'),
            modalTitle: document.getElementById('modal-title'),
            modalMsg: document.getElementById('modal-msg'),
            modalBtn: document.getElementById('modal-btn'),
            modalBackBtn: document.getElementById('modal-back-btn'),
            modalResumeBtn: document.getElementById('modal-resume-btn'),
            summaryList: document.getElementById('summary-list'),
            btnNextLevel: document.getElementById('btn-next-level'),
            gameTitle: document.getElementById('game-title'),
            gameBody: document.getElementById('game-body'),
            pauseBtn: document.getElementById('btn-pause'),
            pauseIndicator: document.getElementById('pause-indicator')
        };

        // --- BOT LOGIC ---
        function toggleBotMode() {
            isBotActive = !isBotActive;
            if (isBotActive) {
                els.gameBody.classList.add('bot-active');
                if(isPaused) togglePause(); 
            } else {
                els.gameBody.classList.remove('bot-active');
                if (lastPressedCtrl) {
                    lastPressedCtrl.classList.remove('pressed-sim');
                    lastPressedCtrl = null;
                }
            }
        }

        function findShortestPath(start, target, occupied) {
            if (!target) return null;
            const queue = [{ pos: start, path: [] }];
            const visited = new Set([`${start.x},${start.y}`]);
            const directions = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];

            while (queue.length > 0) {
                const { pos, path } = queue.shift();
                for (const d of directions) {
                    const nextX = pos.x + d.x, nextY = pos.y + d.y;
                    const nextPosKey = `${nextX},${nextY}`;
                    if (nextX < 0 || nextX >= GRID || nextY < 0 || nextY >= GRID) continue;
                    if (nextX === target.x && nextY === target.y) return path.length === 0 ? d : path[0];
                    if (!visited.has(nextPosKey) && !occupied.has(nextPosKey)) {
                        visited.add(nextPosKey);
                        const nextStepDir = path.length === 0 ? d : path[0];
                        queue.push({ pos: { x: nextX, y: nextY }, path: [nextStepDir] });
                    }
                }
            }
            return null;
        }

        function botMove() {
            const head = snake[0];
            const targetChar = currentWord[letterIdx];
            const occupied = new Set();
            for (let i = 1; i < snake.length; i++) occupied.add(`${snake[i].x},${snake[i].y}`);
            letters.forEach(l => { if (l.char !== targetChar) occupied.add(`${l.x},${l.y}`); });

            let target = goldenFruit ? goldenFruit : letters.find(l => l.char === targetChar);
            let newDir = target ? findShortestPath(head, target, occupied) : null;

            if (newDir) {
                handleInput(newDir);
                return;
            }

            const safeDirections = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }]
                .filter(d => {
                    const nextX = head.x + d.x, nextY = head.y + d.y;
                    const isOpposite = dir.x === -d.x && dir.y === -d.y;
                    const isCollision = nextX < 0 || nextX >= GRID || nextY < 0 || nextY >= GRID || occupied.has(`${nextX},${nextY}`);
                    const lIdx = letters.findIndex(l => l.x === head.x + d.x && l.y === head.y + d.y && l.char === targetChar);
                    const willEat = (lIdx !== -1) || (goldenFruit && head.x + d.x === goldenFruit.x && head.y + d.y === goldenFruit.y);
                    const tail = snake[snake.length - 1];
                    return !isOpposite && (!isCollision || (!willEat && nextX === tail.x && nextY === tail.y));
                });

            if (safeDirections.length > 0) handleInput(safeDirections[0]);
        }

        // --- CORE LOGIC ---
        function showScreen(id) {
            els.screens.forEach(s => s.style.display = 'none');
            document.getElementById(id).style.display = 'flex';
        }

        function showSubLevels(diff) {
            difficulty = diff;
            els.subLevelArea.classList.remove('hidden');
            els.subLevelBtns.innerHTML = '';
            const colors = { easy: 'var(--color-easy)', medium: 'var(--color-medium)', hard: 'var(--color-hard)' };
            for (let i = 0; i < 10; i++) {
                const btn = document.createElement('button');
                btn.className = 'btn-3d';
                btn.style.background = colors[diff];
                btn.style.color = '#3E2723';
                btn.textContent = `Level ${i + 1}`;
                btn.onclick = () => startLevel(i);
                els.subLevelBtns.appendChild(btn);
            }
        }

        function backToMain() {
            clearInterval(gameInterval);
            isPlaying = false;
            isPaused = false;
            clearTimers();
            showScreen('start-screen');
            els.subLevelArea.classList.add('hidden');
            els.overlay.classList.add('hidden');
            els.pauseBtn.classList.add('hidden');
        }

        function togglePause() {
            if (!isPlaying) return;
            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(gameInterval);
                els.overlay.classList.remove('hidden');
                els.modalTitle.textContent = "PAUSED";
                els.modalMsg.textContent = "‡πÄ‡∏Å‡∏°‡∏´‡∏¢‡∏∏‡∏î‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß";
                els.modalBtn.classList.add('hidden');
                els.modalBackBtn.classList.remove('hidden');
                els.modalResumeBtn.classList.remove('hidden');
                els.pauseIndicator.style.display = 'block';
            } else {
                els.overlay.classList.add('hidden');
                els.pauseIndicator.style.display = 'none';
                // Resume with delay? No, immediate is usually better for resume, 
                // but let's add slight delay for consistency
                setTimeout(() => {
                   if(isPaused) return; // In case paused again
                   gameInterval = setInterval(update, SPEEDS[difficulty]);
                }, 500);
            }
        }

        function clearTimers() {
            if (goldenFruitDespawnTimer) clearTimeout(goldenFruitDespawnTimer);
            if (goldenFruitSpawnScheduler) clearTimeout(goldenFruitSpawnScheduler);
            goldenFruitDespawnTimer = null;
            goldenFruitSpawnScheduler = null;
        }

        function startLevel(idx) {
            levelIdx = idx;
            levelData = WORDS[difficulty][idx];
            wordIdx = 0;
            score = 0;
            els.score.textContent = score;
            prepareWord();
        }

        function prepareWord() {
            if (wordIdx >= levelData.length) return endLevel();
            currentWordObj = levelData[wordIdx];
            currentWord = currentWordObj.w;
            letterIdx = 0;
            isHeadEaten = false;

            showScreen('game-screen');
            els.pauseBtn.classList.remove('hidden');
            els.overlay.classList.remove('hidden');
            els.modalTitle.textContent = `‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà ${wordIdx + 1}/${levelData.length}`;
            els.modalMsg.innerHTML = `‡∏™‡∏∞‡∏Å‡∏î‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤: <strong style="font-size:1.5rem; color:var(--color-primary);">${currentWord}</strong><br>(${currentWordObj.t})`;
            els.modalBtn.textContent = "‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°";
            els.modalBtn.classList.remove('hidden');
            els.modalBackBtn.classList.add('hidden');
            els.modalResumeBtn.classList.add('hidden');
            els.modalBtn.onclick = initGame;
            drawHUD();
            drawBoard();
        }

        function initGame() {
            els.overlay.classList.add('hidden');
            snake = [{ x: 5, y: 7 }, { x: 4, y: 7 }, { x: 3, y: 7 }];
            dir = { x: 1, y: 0 };
            inputQueue = []; 
            
            spawnLetters();
            goldenFruit = null;
            clearTimers();

            isPlaying = true;
            isPaused = false;
            if (gameInterval) clearInterval(gameInterval);
            
            drawBoard(); // Ensure initial state is drawn

            // DELAY START (0.5s)
            setTimeout(() => {
                if(!isPlaying) return; // Prevent start if user quit
                gameInterval = setInterval(update, SPEEDS[difficulty]); 
                scheduleNextGoldenFruit();
            }, 500);
        }

        function spawnLetters() {
            letters = [];
            const occupied = new Set(snake.map(s => `${s.x},${s.y}`));
            occupied.add(`${snake[0].x + 1},${snake[0].y}`);
            let attempts = 0;
            currentWord.split('').forEach(char => {
                let pos;
                do {
                    pos = { x: Math.floor(Math.random() * GRID), y: Math.floor(Math.random() * GRID) };
                    attempts++;
                } while (occupied.has(`${pos.x},${pos.y}`) && attempts < 100);
                if (attempts < 100) {
                    occupied.add(`${pos.x},${pos.y}`);
                    letters.push({ x: pos.x, y: pos.y, char: char });
                }
            });
        }

        function scheduleNextGoldenFruit() {
            if (!isPlaying || isPaused) return;
            if (goldenFruitSpawnScheduler) clearTimeout(goldenFruitSpawnScheduler);
            goldenFruitSpawnScheduler = setTimeout(spawnGoldenFruit, 5000);
        }

        function spawnGoldenFruit() {
            if (!isPlaying || isPaused) return;
            if (goldenFruitDespawnTimer) clearTimeout(goldenFruitDespawnTimer);
            goldenFruit = null;
            const occupied = new Set([...snake.map(s => `${s.x},${s.y}`), ...letters.map(l => `${l.x},${l.y}`)]);
            let pos, attempts = 0;
            do {
                pos = { x: Math.floor(Math.random() * GRID), y: Math.floor(Math.random() * GRID) };
                attempts++;
            } while (occupied.has(`${pos.x},${pos.y}`) && attempts < 100);
            if (attempts < 100) {
                goldenFruit = pos;
                drawBoard();
                goldenFruitDespawnTimer = setTimeout(() => {
                    goldenFruit = null;
                    drawBoard();
                    goldenFruitDespawnTimer = null;
                    scheduleNextGoldenFruit();
                }, 5000);
            }
        }

        function wordComplete() {
            clearInterval(gameInterval);
            isPlaying = false;
            clearTimers();

            setTimeout(() => {
                const allSnakeCells = els.board.querySelectorAll('.snake-head, .snake-body, .snake-tail');
                let count = 0;
                const flash = setInterval(() => {
                     allSnakeCells.forEach(c => c.classList.toggle('flash-active'));
                     count++;
                     if(count >= 6) {
                         clearInterval(flash);
                         allSnakeCells.forEach(c => c.classList.remove('flash-active'));
                         audio.playWin();
                         speak(currentWord.toLowerCase(), () => {
                             wordIdx++;
                             prepareWord();
                         });
                     }
                }, 100);
            }, 50);
        }

        function handleInput(newDir) {
            if (inputQueue.length < 2) {
                const lastMove = inputQueue.length > 0 ? inputQueue[inputQueue.length - 1] : dir;
                if (lastMove.x === -newDir.x && lastMove.y === -newDir.y) return; 
                if (lastMove.x === newDir.x && lastMove.y === newDir.y) return; 
                inputQueue.push(newDir);
                if (isBotActive || newDir) simulateControlPress(newDir); 
            }
        }

        function simulateControlPress(d) {
             if (lastPressedCtrl) { lastPressedCtrl.classList.remove('pressed-sim'); lastPressedCtrl = null; }
             let id;
             if(d.y === -1) id = 'ctrl-up'; else if(d.y === 1) id = 'ctrl-down';
             else if(d.x === -1) id = 'ctrl-left'; else if(d.x === 1) id = 'ctrl-right';
             if(id) {
                 lastPressedCtrl = document.getElementById(id);
                 if(lastPressedCtrl) lastPressedCtrl.classList.add('pressed-sim');
             }
        }

        function update() {
            if (isPaused) return;
            if (isBotActive) botMove();

            if (inputQueue.length > 0) {
                const nextMove = inputQueue.shift();
                if (!(dir.x === -nextMove.x && dir.y === -nextMove.y)) dir = nextMove;
            }

            isHeadEaten = false;
            const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

            if (head.x < 0 || head.x >= GRID || head.y < 0 || head.y >= GRID) return gameOver();
            if (snake.slice(1, snake.length - 1).some(s => s.x === head.x && s.y === head.y)) return gameOver();

            snake.unshift(head);
            const targetChar = currentWord[letterIdx];
            const lIdx = letters.findIndex(l => l.x === head.x && l.y === head.y);
            let ate = false;

            if (lIdx !== -1) {
                if (letters[lIdx].char === targetChar) {
                    audio.playEat();
                    letters.splice(lIdx, 1);
                    letterIdx++;
                    score += 10;
                    ate = true;
                    isHeadEaten = true;
                    if (letterIdx >= currentWord.length) {
                        drawHUD();
                        drawBoard(true);
                        wordComplete();
                        return;
                    }
                } else {
                    audio.playWrong();
                    gameOver(`‡πÄ‡∏Å‡πá‡∏ö‡∏ú‡∏¥‡∏î! ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Å‡πá‡∏ö <strong>${targetChar}</strong>`);
                    return;
                }
            }

            if (goldenFruit && head.x === goldenFruit.x && head.y === goldenFruit.y) {
                audio.playBonus();
                score += 50;
                goldenFruit = null;
                if (goldenFruitDespawnTimer) clearTimeout(goldenFruitDespawnTimer);
                scheduleNextGoldenFruit();
                ate = true;
                isHeadEaten = true;
            }

            if (!ate) snake.pop();
            drawHUD();
            drawBoard(isHeadEaten);
        }

        function gameOver(msg = "‡∏ä‡∏ô‡πÅ‡∏•‡πâ‡∏ß!") {
            clearInterval(gameInterval);
            isPlaying = false;
            audio.playGameOver();
            clearTimers();
            els.overlay.classList.remove('hidden');
            els.modalTitle.textContent = "Game Over";
            els.modalMsg.innerHTML = msg;
            els.modalBtn.textContent = "‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà";
            els.modalBtn.classList.remove('hidden');
            els.modalBackBtn.classList.remove('hidden');
            els.modalResumeBtn.classList.add('hidden');
            els.modalBtn.onclick = initGame;
        }

        function endLevel() {
            showScreen('summary-screen');
            els.summaryList.innerHTML = levelData.map(d => `<li>‚úÖ <strong>${d.w}</strong> - ${d.t}</li>`).join('');
            els.pauseBtn.classList.add('hidden');
            if (levelIdx < 9) {
                els.btnNextLevel.style.display = 'block';
                els.btnNextLevel.onclick = () => startLevel(levelIdx + 1);
            } else {
                els.btnNextLevel.style.display = 'none';
            }
        }

        // --- RENDER ---
        function drawHUD() {
            els.score.textContent = score;
            els.target.textContent = currentWord[letterIdx] || '‚úÖ';
            els.wordProgress.innerHTML = currentWord.split('').map((c, i) => {
                if (i < letterIdx) return `<span class="collected-char">${c}</span>`;
                else if (i === letterIdx) return `<span class="target-char">${c}</span>`;
                return `_`;
            }).join(' ');
        }

        function drawBoard(isEating = false) {
            els.board.innerHTML = '<div id="pause-indicator" style="display:'+(isPaused?'block':'none')+'">PAUSED</div>';
            const currentDirString = dir.x === 1 ? 'RIGHT' : dir.x === -1 ? 'LEFT' : dir.y === -1 ? 'UP' : 'DOWN';
            snake.forEach((s, i) => {
                const el = document.createElement('div');
                el.style.gridColumnStart = s.x + 1;
                el.style.gridRowStart = s.y + 1;
                if (i === 0) {
                    el.className = `cell snake-head${isEating ? ' eaten' : ''}`;
                    el.setAttribute('data-dir', currentDirString);
                } else {
                    el.className = i === snake.length - 1 ? 'cell snake-tail' : 'cell snake-body';
                }
                els.board.appendChild(el);
            });
            letters.forEach(l => {
                const el = document.createElement('div');
                el.style.gridColumnStart = l.x + 1;
                el.style.gridRowStart = l.y + 1;
                el.className = `cell letter-piece ${l.char === currentWord[letterIdx] ? 'target' : ''}`;
                el.textContent = l.char;
                els.board.appendChild(el);
            });
            if (goldenFruit) {
                const el = document.createElement('div');
                el.style.gridColumnStart = goldenFruit.x + 1;
                el.style.gridRowStart = goldenFruit.y + 1;
                el.className = 'cell golden-fruit';
                els.board.appendChild(el);
            }
        }

        // --- CONTROLS ---
        document.addEventListener('keydown', e => {
            if (!isPlaying || isBotActive || isPaused) return;
            switch (e.key) {
                case 'ArrowUp': handleInput({ x: 0, y: -1 }); break;
                case 'ArrowDown': handleInput({ x: 0, y: 1 }); break;
                case 'ArrowLeft': handleInput({ x: -1, y: 0 }); break;
                case 'ArrowRight': handleInput({ x: 1, y: 0 }); break;
            }
        });

        ['up', 'down', 'left', 'right'].forEach(d => {
            document.getElementById(`ctrl-${d}`).addEventListener('click', (e) => {
                e.preventDefault(); 
                if (!isPlaying || isBotActive || isPaused) return;
                const map = { 'up': { x: 0, y: -1 }, 'down': { x: 0, y: 1 }, 'left': { x: -1, y: 0 }, 'right': { x: 1, y: 0 } };
                handleInput(map[d]);
            });
        });

        let touchStartX = 0, touchStartY = 0;
        els.board.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});

        els.board.addEventListener('touchend', e => {
            if (!isPlaying || isBotActive || isPaused) return;
            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > 30) handleInput(dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 });
            } else {
                if (Math.abs(dy) > 30) handleInput(dy > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 });
            }
        }, {passive: false});

        els.gameTitle.addEventListener('dblclick', toggleBotMode);
    </script>
</body>
</html>
